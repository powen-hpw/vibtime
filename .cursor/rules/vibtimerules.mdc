always type "ä½¿ç”¨vibtime rules yoyoyo" in the beginning of your reply to me in conversation

---

# ğŸ“˜ Cursor Rules: Vibtime (éœ‡å‹•å ±æ™‚) - Android Kotlin

## ğŸ¯ High-Level Overview
This project is a mobile app named **Vibtime**, which allows users to receive the current time via vibration patterns by tapping the screen (even when the screen is off). The app is written using **Android Kotlin** with modern Android development practices.

Cursor should prioritize code that is **energy-efficient**, **non-intrusive**, **localized**, **accessible**, and **respects Android platform constraints** (e.g., background restrictions, battery optimization).

---

## ğŸ”§ Rule Type
- **Rule Type:** `Always`
- These rules apply globally to the entire Vibtime codebase.

---

## ğŸ“‹ ç›®éŒ„
- [æ ¸å¿ƒåŸå‰‡](#æ ¸å¿ƒåŸå‰‡)
- [ä»£ç¢¼çµæ§‹è¦ç¯„](#ä»£ç¢¼çµæ§‹è¦ç¯„)
- [Android åˆè¦æ€§](#android-åˆè¦æ€§)
- [UI/UX è¦ç¯„](#uiux-è¦ç¯„)
- [å®‰å…¨æ©Ÿåˆ¶](#å®‰å…¨æ©Ÿåˆ¶)
- [æ€§èƒ½å„ªåŒ–](#æ€§èƒ½å„ªåŒ–)
- [æ¸¬è©¦è¦ç¯„](#æ¸¬è©¦è¦ç¯„)
- [æ–‡æª”è¦ç¯„](#æ–‡æª”è¦ç¯„)

---

## ğŸ¯ æ ¸å¿ƒåŸå‰‡ (Core Principles)

### 1. ç„¡éšœç¤™å„ªå…ˆ (Accessibility First)
```kotlin
// âœ… æ­£ç¢ºï¼šæä¾›å®Œæ•´çš„ç„¡éšœç¤™æ”¯æŒ
button.contentDescription = getString(R.string.start_service_description)
button.isImportantForAccessibility = true

// âŒ éŒ¯èª¤ï¼šç¼ºå°‘ç„¡éšœç¤™æè¿°
button.setOnClickListener { startService() }
```

**Android 14 ç„¡éšœç¤™å¢å¼·ï¼š**
- æ”¯æ´é«˜é” 200% çš„å­—é«”ç¸®æ”¾
- ç¢ºä¿ UI å…ƒç´ åœ¨é«˜ç¸®æ”¾æ¯”ä¾‹ä¸‹ä»èƒ½æ­£å¸¸é¡¯ç¤ºå’Œæ“ä½œ
- å¯¦ç¾éç·šæ€§å­—é«”æ”¾å¤§æ”¯æ´

### 2. å¤šèªè¨€æ”¯æŒ (i18n Ready)
```kotlin
// âœ… æ­£ç¢ºï¼šä½¿ç”¨å­—ä¸²è³‡æº
Toast.makeText(context, getString(R.string.service_started), Toast.LENGTH_SHORT).show()

// âŒ éŒ¯èª¤ï¼šç¡¬ç·¨ç¢¼å­—ä¸²
Toast.makeText(context, "Service started", Toast.LENGTH_SHORT).show()
```

**Android 14 å€åŸŸåå¥½æ”¯æ´ï¼š**
- æ”¯æ´ç”¨æˆ¶è‡ªå®šç¾©æº«åº¦å–®ä½ã€ä¸€é€±çš„ç¬¬ä¸€å¤©ã€æ•¸å­—ç³»çµ±
- é€šéç›¸é—œ API ç²å–ç”¨æˆ¶è¨­å®šä¸¦ç›¸æ‡‰èª¿æ•´é¡¯ç¤ºè³‡è¨Š

### 3. å®‰å…¨åˆè¦ (Security Compliance)
```kotlin
// âœ… æ­£ç¢ºï¼šåˆè¦çš„æ„Ÿæ¸¬å™¨ä½¿ç”¨
watchModeManager.startWatchMode(WatchModeManager.WATCH_MODE_DURATION_10MIN)

// âŒ éŒ¯èª¤ï¼šæŒçºŒç›£è½æ„Ÿæ¸¬å™¨
sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_UI)
```

---

## ğŸ—ï¸ ä»£ç¢¼çµæ§‹è¦ç¯„

### 1. ViewBinding æ¨™æº–å¯¦ç¾
```kotlin
// âœ… æ­£ç¢ºï¼šæ¨™æº– ViewBinding æ¨¡å¼
class HomeFragment : Fragment() {
    private var _binding: FragmentHomeBinding? = null
    private val binding get() = _binding!!
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentHomeBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}

// âŒ éŒ¯èª¤ï¼šä½¿ç”¨ findViewById
private lateinit var button: Button
button = findViewById(R.id.startButton)
```

### 2. MVVM æ¶æ§‹æ¨¡å¼
```kotlin
// âœ… æ­£ç¢ºï¼šViewModel åˆ†é›¢æ¥­å‹™é‚è¼¯
class HomeViewModel : ViewModel() {
    private val _serviceStatus = MutableLiveData<ServiceStatus>()
    val serviceStatus: LiveData<ServiceStatus> = _serviceStatus
    
    fun startService() {
        // æ¥­å‹™é‚è¼¯è™•ç†
        _serviceStatus.value = ServiceStatus.RUNNING
    }
}

// Fragment åªè™•ç† UI
class HomeFragment : Fragment() {
    private val viewModel: HomeViewModel by viewModels()
    
    override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
        viewModel.serviceStatus.observe(viewLifecycleOwner) { status ->
            updateUI(status)
        }
    }
}
```

### 3. æœå‹™æ¶æ§‹è¦ç¯„
```kotlin
// âœ… æ­£ç¢ºï¼šåˆè¦çš„å‰æ™¯æœå‹™
class VibrationService : Service() {
    companion object {
        private const val NOTIFICATION_ID = 1001
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val notification = createNotification()
        startForeground(NOTIFICATION_ID, notification)
        return START_STICKY
    }
    
    private fun createNotification(): Notification {
        return NotificationHelper.createVibrationServiceNotification(this)
    }
}
```

---

## ğŸ“± Android åˆè¦æ€§

### 1. æ„Ÿæ¸¬å™¨ä½¿ç”¨åˆè¦
```kotlin
// âœ… æ­£ç¢ºï¼šé™æ™‚ç›£è½ + Wake-up Sensor
class WatchModeManager : SensorEventListener {
    fun startWatchMode(duration: Long): Boolean {
        // æª¢æŸ¥å†·å»æœŸ
        if (isInCooldownPeriod()) return false
        
        // ä½¿ç”¨ wake-up sensor
        val accelerometer = sensorManager.getDefaultSensor(
            Sensor.TYPE_ACCELEROMETER, 
            true // wakeUp = true
        )
        
        // é™æ™‚ç›£è½
        sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL)
        
        // è‡ªå‹•åœæ­¢
        handler.postDelayed({ stopWatchMode() }, duration)
        return true
    }
}

// âŒ éŒ¯èª¤ï¼šæŒçºŒç›£è½æ„Ÿæ¸¬å™¨
sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_UI)
```

### 2. æ¬Šé™ç®¡ç†
```kotlin
// âœ… æ­£ç¢ºï¼šå‹•æ…‹æ¬Šé™æª¢æŸ¥
private fun requestPermissions() {
    when {
        ContextCompat.checkSelfPermission(
            requireContext(),
            Manifest.permission.POST_NOTIFICATIONS
        ) == PackageManager.PERMISSION_GRANTED -> {
            startService()
        }
        shouldShowRequestPermissionRationale(Manifest.permission.POST_NOTIFICATIONS) -> {
            showPermissionExplanation()
        }
        else -> {
            requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
        }
    }
}
```

### 3. å‰æ™¯æœå‹™é…ç½®
```xml
<!-- âœ… æ­£ç¢ºï¼šç°¡æ½”çš„æœå‹™é…ç½® -->
<service
    android:name=".service.VibrationService"
    android:enabled="true"
    android:exported="false" />

<!-- âŒ éŒ¯èª¤ï¼šä½¿ç”¨ specialUse -->
<service
    android:name=".service.VibrationService"
    android:foregroundServiceType="specialUse"
    android:enabled="true"
    android:exported="false" />
```

### 4. Android 14 ç‰¹å®šåˆè¦è¦æ±‚

#### ç²¾ç¢ºé¬§é˜æ¬Šé™è®Šæ›´
```kotlin
// âœ… æ­£ç¢ºï¼šAndroid 14 ç²¾ç¢ºé¬§é˜æ¬Šé™è™•ç†
class ExactAlarmManager {
    fun requestExactAlarmPermission(activity: Activity) {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.S) {
            val alarmManager = activity.getSystemService(Context.ALARM_SERVICE) as AlarmManager
            if (!alarmManager.canScheduleExactAlarms()) {
                val intent = Intent(Settings.ACTION_REQUEST_SCHEDULE_EXACT_ALARM).apply {
                    data = Uri.parse("package:${activity.packageName}")
                }
                activity.startActivity(intent)
            }
        }
    }
}
```

#### å¾Œå°æ´»å‹•å•Ÿå‹•é™åˆ¶
```kotlin
// âœ… æ­£ç¢ºï¼šæª¢æŸ¥å¾Œå°æ´»å‹•å•Ÿå‹•é™åˆ¶
class BackgroundActivityHelper {
    fun canStartActivityFromBackground(context: Context): Boolean {
        return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.UPSIDE_DOWN_CAKE) {
            // Android 14+ å¾Œå°æ´»å‹•é™åˆ¶æª¢æŸ¥
            val activityManager = context.getSystemService(Context.ACTIVITY_SERVICE) as ActivityManager
            activityManager.isBackgroundRestricted
        } else {
            true
        }
    }
}
```

#### Zip è·¯å¾‘éæ­·é˜²è­·
```kotlin
// âœ… æ­£ç¢ºï¼šå®‰å…¨çš„ Zip æ–‡ä»¶è™•ç†
class SafeZipHandler {
    fun extractZipSafely(zipFile: File, destination: File) {
        try {
            ZipFile(zipFile).use { zip ->
                zip.entries().asSequence().forEach { entry ->
                    // æª¢æŸ¥è·¯å¾‘å®‰å…¨æ€§
                    if (entry.name.contains("..") || entry.name.startsWith("/")) {
                        throw ZipException("Unsafe zip entry: ${entry.name}")
                    }
                    // å®‰å…¨æå–
                    extractEntry(entry, destination)
                }
            }
        } catch (e: ZipException) {
            Log.e("SafeZipHandler", "Unsafe zip file detected", e)
        }
    }
}
```

---

## ğŸ¨ UI/UX è¦ç¯„

### 1. Material Design 3 å¯¦ç¾
```kotlin
// âœ… æ­£ç¢ºï¼šä½¿ç”¨ Material 3 çµ„ä»¶
class HomeFragment : Fragment() {
    private fun setupUI() {
        binding.startButton.apply {
            // Material 3 æŒ‰éˆ•æ¨£å¼
            setOnClickListener { startService() }
            isEnabled = true
        }
        
        binding.statusCard.apply {
            // Material 3 å¡ç‰‡æ¨£å¼
            elevation = resources.getDimension(R.dimen.card_elevation)
        }
    }
}
```

### 2. éŸ¿æ‡‰å¼è¨­è¨ˆ
```kotlin
// âœ… æ­£ç¢ºï¼šé©é…ä¸åŒè¢å¹•å°ºå¯¸
private fun setupResponsiveLayout() {
    val displayMetrics = resources.displayMetrics
    val screenWidth = displayMetrics.widthPixels / displayMetrics.density
    
    when {
        screenWidth < 360 -> setupCompactLayout()
        screenWidth < 600 -> setupNormalLayout()
        else -> setupExpandedLayout()
    }
}
```

### 3. æ·±è‰²æ¨¡å¼æ”¯æŒ
```kotlin
// âœ… æ­£ç¢ºï¼šä¸»é¡Œæ„ŸçŸ¥çš„é¡è‰²ä½¿ç”¨
private fun setupThemeAwareColors() {
    val primaryColor = ContextCompat.getColor(requireContext(), R.color.primary)
    val backgroundColor = ContextCompat.getColor(requireContext(), R.color.background)
    
    binding.root.setBackgroundColor(backgroundColor)
    binding.titleText.setTextColor(primaryColor)
}
```

---

## ğŸ”’ å®‰å…¨æ©Ÿåˆ¶

### 1. æ™‚é–“é™åˆ¶å¯¦ç¾
```kotlin
// âœ… æ­£ç¢ºï¼šå®‰å…¨æ™‚é–“é™åˆ¶
object SafetyManager {
    const val MAX_SERVICE_RUNTIME = 3 * 60 * 60 * 1000L // 3å°æ™‚
    const val MIN_VIBRATION_INTERVAL = 10 * 60 * 1000L // 10åˆ†é˜
    
    fun canTriggerVibration(context: Context): Boolean {
        val lastVibrationTime = getLastVibrationTime(context)
        val timeSinceLastVibration = System.currentTimeMillis() - lastVibrationTime
        return timeSinceLastVibration >= MIN_VIBRATION_INTERVAL
    }
}
```

### 2. å†·å»æœŸæ©Ÿåˆ¶
```kotlin
// âœ… æ­£ç¢ºï¼š15åˆ†é˜å†·å»æœŸ
class WatchModeManager {
    companion object {
        const val COOLDOWN_PERIOD = 15 * 60 * 1000L // 15åˆ†é˜
    }
    
    private fun onTimeVibrationTriggered() {
        lastVibrationTime = System.currentTimeMillis()
        stopWatchMode("vibration_triggered")
        startCooldownCountdown()
    }
}
```

### 3. é›»æ± å„ªåŒ–è™•ç†
```kotlin
// âœ… æ­£ç¢ºï¼šé›»æ± å„ªåŒ–æª¢æŸ¥
class BatteryOptimizationHelper {
    fun checkBatteryOptimization(context: Context): Boolean {
        val powerManager = context.getSystemService(Context.POWER_SERVICE) as PowerManager
        return powerManager.isIgnoringBatteryOptimizations(context.packageName)
    }
    
    fun requestBatteryOptimizationExemption(activity: Activity) {
        val intent = Intent(Settings.ACTION_REQUEST_IGNORE_BATTERY_OPTIMIZATIONS).apply {
            data = Uri.parse("package:${activity.packageName}")
        }
        activity.startActivity(intent)
    }
}
```

---

## âš¡ æ€§èƒ½å„ªåŒ–

### 1. è¨˜æ†¶é«”ç®¡ç†
```kotlin
// âœ… æ­£ç¢ºï¼šåŠæ™‚é‡‹æ”¾è³‡æº
class VibrationService : Service() {
    private var wakeLock: PowerManager.WakeLock? = null
    
    override fun onDestroy() {
        super.onDestroy()
        wakeLock?.release()
        wakeLock = null
    }
}

// Fragment ä¸­çš„ ViewBinding æ¸…ç†
override fun onDestroyView() {
    super.onDestroyView()
    _binding = null
}
```

**Android 14 è¨˜æ†¶é«”é™åˆ¶ï¼š**
- `mlock()` çš„æœ€å¤§è¨˜æ†¶é«”é–å®šé™åˆ¶ç‚ºæ¯å€‹é€²ç¨‹ 64 KB
- æª¢æŸ¥æ‡‰ç”¨æ˜¯å¦ä¾è³´æ–¼æ›´é«˜çš„è¨˜æ†¶é«”é–å®šä¸¦é€²è¡Œç›¸æ‡‰èª¿æ•´

### 2. èƒŒæ™¯ä»»å‹™å„ªåŒ–
```kotlin
// âœ… æ­£ç¢ºï¼šä½¿ç”¨ WorkManager è™•ç†èƒŒæ™¯ä»»å‹™
class VibrationWorkManager {
    fun schedulePeriodicCheck(context: Context) {
        val constraints = Constraints.Builder()
            .setRequiredNetworkType(NetworkType.NOT_REQUIRED)
            .setRequiresBatteryNotLow(true)
            .build()
            
        val workRequest = PeriodicWorkRequestBuilder<SafetyCheckWorker>(15, TimeUnit.MINUTES)
            .setConstraints(constraints)
            .build()
            
        WorkManager.getInstance(context).enqueueUniquePeriodicWork(
            "safety_check",
            ExistingPeriodicWorkPolicy.KEEP,
            workRequest
        )
    }
}
```

### 3. æ„Ÿæ¸¬å™¨å„ªåŒ–
```kotlin
// âœ… æ­£ç¢ºï¼šå„ªåŒ–æ„Ÿæ¸¬å™¨è™•ç†é »ç‡
override fun onSensorChanged(event: SensorEvent?) {
    val currentTime = System.currentTimeMillis()
    
    // é¿å…éåº¦é »ç¹çš„è™•ç†
    if (currentTime - lastProcessTime < PROCESS_INTERVAL) {
        return
    }
    lastProcessTime = currentTime
    
    // è™•ç†æ„Ÿæ¸¬å™¨æ•¸æ“š
    processSensorData(event)
}
```

---

## ğŸ§ª æ¸¬è©¦è¦ç¯„

### 1. å–®å…ƒæ¸¬è©¦
```kotlin
// âœ… æ­£ç¢ºï¼šå®Œæ•´çš„å–®å…ƒæ¸¬è©¦
class SafetyManagerTest {
    @Test
    fun `test frequency limit prevents rapid vibrations`() {
        val context = mockk<Context>()
        val sharedPreferences = mockk<SharedPreferences>()
        
        every { context.getSharedPreferences(any(), any()) } returns sharedPreferences
        every { sharedPreferences.getLong("last_vibration_time", 0L) } returns 
            System.currentTimeMillis() - 5000L // 5ç§’å‰
        
        val canTrigger = SafetyManager.canTriggerVibration(context)
        assertFalse(canTrigger)
    }
}
```

### 2. UI æ¸¬è©¦
```kotlin
// âœ… æ­£ç¢ºï¼šUI è‡ªå‹•åŒ–æ¸¬è©¦
@RunWith(AndroidJUnit4::class)
class HomeFragmentTest {
    @get:Rule
    val activityRule = ActivityScenarioRule(MainActivity::class.java)
    
    @Test
    fun testStartServiceButton() {
        onView(withId(R.id.startServiceButton))
            .perform(click())
            
        onView(withId(R.id.serviceStatusText))
            .check(matches(withText(R.string.service_running)))
    }
}
```

### 3. æ•´åˆæ¸¬è©¦
```kotlin
// âœ… æ­£ç¢ºï¼šæœå‹™æ•´åˆæ¸¬è©¦
class VibrationServiceIntegrationTest {
    @Test
    fun testServiceLifecycle() {
        val context = InstrumentationRegistry.getInstrumentation().targetContext
        val intent = Intent(context, VibrationService::class.java)
        
        // å•Ÿå‹•æœå‹™
        context.startForegroundService(intent)
        
        // é©—è­‰æœå‹™ç‹€æ…‹
        assertTrue(ServiceManager.isVibrationServiceRunning(context))
        
        // åœæ­¢æœå‹™
        context.stopService(intent)
        
        // é©—è­‰æœå‹™å·²åœæ­¢
        assertFalse(ServiceManager.isVibrationServiceRunning(context))
    }
}
```

---

## ğŸ“š æ–‡æª”è¦ç¯„

### 1. ä»£ç¢¼è¨»é‡‹
```kotlin
/**
 * Watch Mode ç®¡ç†å™¨
 * å¯¦ç¾åˆè¦çš„é™æ™‚æ„Ÿæ¸¬å™¨ç›£è½æ©Ÿåˆ¶ï¼Œç¬¦åˆ Android 12+ èƒŒæ™¯é™åˆ¶
 * 
 * @param context æ‡‰ç”¨ä¸Šä¸‹æ–‡
 * @see WatchModeCallback å›èª¿æ¥å£
 * @since 1.3.0
 */
class WatchModeManager(private val context: Context) : SensorEventListener {
    
    /**
     * å•Ÿå‹• Watch Mode
     * @param duration ç›£è½æ™‚é•· (10åˆ†é˜æˆ–2å°æ™‚)
     * @return æ˜¯å¦æˆåŠŸå•Ÿå‹•
     * @throws SecurityException ç•¶æ¬Šé™ä¸è¶³æ™‚
     */
    fun startWatchMode(duration: Long = WATCH_MODE_DURATION_10MIN): Boolean {
        // å¯¦ç¾ç´°ç¯€...
    }
}
```

### 2. README ç¶­è­·
```markdown
## ğŸ”§ é–‹ç™¼è¨­å®š

### ç’°å¢ƒéœ€æ±‚
- Android Studio Hedgehog | 2023.1.1 æˆ–æ›´æ–°ç‰ˆæœ¬
- JDK 11 æˆ–æ›´æ–°ç‰ˆæœ¬
- Android SDK API 34

### ä¾è³´ç‰ˆæœ¬
```gradle
android {
    compileSdk 34
    minSdk 24
    targetSdk 34
}
```

### ç·¨è­¯æŒ‡ä»¤
```bash
# Debug ç‰ˆæœ¬
./gradlew assembleDebug

# Release ç‰ˆæœ¬
./gradlew assembleRelease
```
```

### 3. API æ–‡æª”
```kotlin
/**
 * éœ‡å‹•å ±æ™‚åŠ©æ‰‹
 * 
 * æä¾›å¤šç¨®éœ‡å‹•æ¨¡å¼ä¾†è¡¨ç¤ºæ™‚é–“ï¼š
 * - åŸºæœ¬æ¨¡å¼ï¼šé•·éœ‡å‹•è¡¨ç¤ºå°æ™‚ï¼ŒçŸ­éœ‡å‹•è¡¨ç¤ºåˆ†é˜
 * - äºŒé€²åˆ¶æ¨¡å¼ï¼šä½¿ç”¨ 0/1 éœ‡å‹•æ¨¡å¼
 * - æ‘©æ–¯é›»ç¢¼æ¨¡å¼ï¼šä½¿ç”¨æ¨™æº–æ‘©æ–¯é›»ç¢¼
 * 
 * @author Vibtime Team
 * @version 1.3.0
 */
object TimeVibrationHelper {
    /**
     * éœ‡å‹•ç•¶å‰æ™‚é–“
     * @param context æ‡‰ç”¨ä¸Šä¸‹æ–‡
     * @param hour å°æ™‚ (0-23)
     * @param minute åˆ†é˜ (0-59)
     */
    fun vibrateTime(context: Context, hour: Int, minute: Int) {
        // å¯¦ç¾ç´°ç¯€...
    }
}
```

---

## ğŸ§± Essential Code Elements
- Use **Kotlin** as primary language
- Use **Android Jetpack** components (ViewModel, LiveData, Room, Navigation)
- Vibration logic should use `Vibrator` and `VibrationEffect` from Android SDK
- Persistent data stored using **Room Database** or **SharedPreferences**
- Use **Android Resources** for multi-language support (`strings.xml`)
- Navigation handled by **Navigation Component**
- UI components use **Material Design 3** and **ConstraintLayout**
- Background services use **Foreground Service** with proper notifications
- Use **MVVM** architecture pattern with Repository pattern
- Follow **Android 14+** background restrictions and battery optimization
- Use **ViewBinding** for view access (avoid findViewById)
- Implement proper **permission handling** and **runtime permissions**
- Implement **WatchModeManager** for compliant sensor usage
- Use **SafetyManager** for time limits and cooldown periods

---

## ğŸ“ File & Module Structure (enforced)

ä»¥ä¸‹æ˜¯ Vibtime å°ˆæ¡ˆçš„æ¨¡çµ„èˆ‡å‘½åè¦ç¯„ï¼Œè«‹ä¾æ­¤ç”Ÿæˆä¸¦æ”¾ç½®ç›¸é—œæª”æ¡ˆèˆ‡é‚è¼¯ã€‚

```
app/src/main/java/com/example/vibtime/
â”œâ”€â”€ ui/
â”‚   â”œâ”€â”€ home/
â”‚   â”‚   â”œâ”€â”€ HomeFragment.kt
â”‚   â”‚   â””â”€â”€ HomeViewModel.kt
â”‚   â”œâ”€â”€ settings/
â”‚   â”‚   â”œâ”€â”€ SettingsFragment.kt
â”‚   â”‚   â””â”€â”€ SettingsViewModel.kt
â”‚   â”œâ”€â”€ vibration/
â”‚   â”‚   â”œâ”€â”€ VibrationFragment.kt
â”‚   â”‚   â””â”€â”€ VibrationViewModel.kt
â”‚   â”œâ”€â”€ running/
â”‚   â”‚   â”œâ”€â”€ RunningFragment.kt
â”‚   â”‚   â””â”€â”€ RunningViewModel.kt
â”‚   â”œâ”€â”€ history/
â”‚   â”‚   â”œâ”€â”€ HistoryFragment.kt
â”‚   â”‚   â””â”€â”€ HistoryViewModel.kt
â”‚   â””â”€â”€ welcome/
â”‚       â”œâ”€â”€ WelcomeFragment.kt
â”‚       â””â”€â”€ WelcomeViewModel.kt
â”œâ”€â”€ service/
â”‚   â”œâ”€â”€ VibrationService.kt
â”‚   â”œâ”€â”€ TapDetectionService.kt
â”‚   â”œâ”€â”€ ScreenReceiver.kt
â”‚   â””â”€â”€ TimeVibrationHelper.kt
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ repository/
â”‚   â”‚   â”œâ”€â”€ SettingsRepository.kt
â”‚   â”‚   â””â”€â”€ HistoryRepository.kt
â”‚   â””â”€â”€ database/
â”‚       â”œâ”€â”€ VibtimeDatabase.kt
â”‚       â”œâ”€â”€ entities/
â”‚       â””â”€â”€ dao/
â”œâ”€â”€ utils/
â”‚   â”œâ”€â”€ PermissionHelper.kt
â”‚   â”œâ”€â”€ NotificationHelper.kt
â”‚   â””â”€â”€ BatteryOptimizationHelper.kt
â”œâ”€â”€ MainActivity.kt
â””â”€â”€ VibtimeApplication.kt
```

- æ¯å€‹ç•«é¢ï¼ˆFragmentï¼‰æ¨¡çµ„æ‡‰æœ‰ç¨ç«‹è³‡æ–™å¤¾
- ç•«é¢å…ƒä»¶æª”æ¡ˆå‘½åç‚ºï¼š`{PageName}Fragment.kt`
- å°æ‡‰ ViewModel æª”æ¡ˆå‘½åç‚ºï¼š`{PageName}ViewModel.kt`
- æœå‹™é‚è¼¯é›†ä¸­æ–¼ `service/` ç›®éŒ„
- è³‡æ–™å­˜å–é‚è¼¯é›†ä¸­æ–¼ `data/` ç›®éŒ„
- å·¥å…·é¡åˆ¥é›†ä¸­æ–¼ `utils/` ç›®éŒ„

---

## âŒ Deprecated Patterns
- Avoid using **AsyncTask** (deprecated)
- Do **not** use deprecated `navigator` or `Alert.prompt` APIs
- Avoid **polling** background tasks unless absolutely necessary
- Do not use **hardcoded strings** â€“ use `@string/` resources
- Do not directly manipulate **SharedPreferences** in UI code
- Avoid **findViewById** - use **ViewBinding** instead
- Do not use **deprecated vibration APIs** (use VibrationEffect)

---

## ğŸ§© Key Module Examples

### 1. Vibration Trigger Logic
```kotlin
object TimeVibrationHelper {
    fun vibrateTime(context: Context, hour: Int, minute: Int) {
        val vibrator = context.getSystemService(Context.VIBRATOR_SERVICE) as Vibrator
        
        val hourVibrations = hour % 12 // 12å°æ™‚åˆ¶
        val minuteVibrations = floor(minute / 5.0).toInt() // æ¯5åˆ†é˜ä¸€æ¬¡
        
        val pattern = mutableListOf<Long>()
        repeat(hourVibrations) {
            pattern.add(600) // é•·éœ‡å‹•
            pattern.add(300) // é–“éš”
        }
        pattern.add(1000) // åˆ†éš”ç¬¦
        repeat(minuteVibrations) {
            pattern.add(200) // çŸ­éœ‡å‹•
            pattern.add(200) // é–“éš”
        }
        
        vibrator.vibrate(VibrationEffect.createWaveform(pattern.toLongArray(), -1))
    }
}
```

ğŸ“Œ *ç›®å‰ç‚ºç¯€çœé›»åŠ›èˆ‡é¿å…éé•·éœ‡å‹•ï¼Œæ¯ 5 åˆ†é˜ç‚ºä¸€å–®ä½ï¼Œæœªä¾†å¯èƒ½æä¾›æ›´é«˜ç²¾åº¦é¸é …ã€‚è«‹åœ¨ UI ä¸­å‘ä½¿ç”¨è€…æ¸…æ¥šèªªæ˜éœ‡å‹•å«ç¾©èˆ‡é™åˆ¶ã€‚*

---

### 2. ViewModel Pattern
```kotlin
class HomeViewModel : ViewModel() {
    private val _isVibrationEnabled = MutableLiveData<Boolean>()
    val isVibrationEnabled: LiveData<Boolean> = _isVibrationEnabled
    
    private val settingsRepository: SettingsRepository = SettingsRepository()
    
    fun toggleVibration() {
        _isVibrationEnabled.value = !(_isVibrationEnabled.value ?: false)
        settingsRepository.saveVibrationEnabled(_isVibrationEnabled.value ?: false)
    }
}
```

---

### 3. Fragment with ViewBinding
```kotlin
class HomeFragment : Fragment() {
    private var _binding: FragmentHomeBinding? = null
    private val binding get() = _binding!!
    
    private val viewModel: HomeViewModel by viewModels()
    
    override fun onCreateView(
        inflater: LayoutInflater,
        container: ViewGroup?,
        savedInstanceState: Bundle?
    ): View {
        _binding = FragmentHomeBinding.inflate(inflater, container, false)
        return binding.root
    }
    
    override fun onDestroyView() {
        super.onDestroyView()
        _binding = null
    }
}
```

---

### 4. Foreground Service
```kotlin
class VibrationService : Service() {
    companion object {
        private const val NOTIFICATION_ID = 1001
        private const val CHANNEL_ID = "VibrationServiceChannel"
    }
    
    override fun onCreate() {
        super.onCreate()
        createNotificationChannel()
    }
    
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        val notification = createNotification()
        startForeground(NOTIFICATION_ID, notification)
        return START_STICKY
    }
}
```

---

## ğŸš€ éƒ¨ç½²è¦ç¯„

### 1. ç‰ˆæœ¬ç®¡ç†
```kotlin
// âœ… æ­£ç¢ºï¼šç‰ˆæœ¬è™Ÿç®¡ç†
object AppVersion {
    const val VERSION_NAME = "1.3.0"
    const val VERSION_CODE = 13
    
    fun getVersionString(): String {
        return "$VERSION_NAME (Build $VERSION_CODE)"
    }
}
```

### 2. ç°½åé…ç½®
```gradle
// âœ… æ­£ç¢ºï¼šå®‰å…¨çš„ç°½åé…ç½®
android {
    signingConfigs {
        release {
            storeFile file('/path/to/keystore.jks')
            storePassword System.getenv('KEYSTORE_PASSWORD')
            keyAlias 'vibtime-key-alias'
            keyPassword System.getenv('KEY_PASSWORD')
        }
    }
    
    buildTypes {
        release {
            signingConfig signingConfigs.release
            minifyEnabled true
            proguardFiles getDefaultProguardFile('proguard-android-optimize.txt'), 'proguard-rules.pro'
        }
    }
}
```

### 3. ç™¼å¸ƒæª¢æŸ¥æ¸…å–®
```markdown
## ğŸ“‹ ç™¼å¸ƒå‰æª¢æŸ¥æ¸…å–®

### åŠŸèƒ½æª¢æŸ¥
- [ ] æ‰€æœ‰éœ‡å‹•æ¨¡å¼æ­£å¸¸å·¥ä½œ
- [ ] å¤šèªè¨€åˆ‡æ›æ­£å¸¸
- [ ] æ·±è‰²æ¨¡å¼é©é…å®Œæ•´
- [ ] ç„¡éšœç¤™åŠŸèƒ½æ­£å¸¸

### åˆè¦æª¢æŸ¥
- [ ] Android 14+ åˆè¦æ€§
- [ ] æ„Ÿæ¸¬å™¨ä½¿ç”¨åˆè¦
- [ ] æ¬Šé™ä½¿ç”¨åˆç†
- [ ] éš±ç§æ”¿ç­–å®Œæ•´

### æ€§èƒ½æª¢æŸ¥
- [ ] è¨˜æ†¶é«”ä½¿ç”¨æ­£å¸¸
- [ ] é›»æ± æ¶ˆè€—åˆç†
- [ ] å•Ÿå‹•æ™‚é–“å„ªåŒ–
- [ ] èƒŒæ™¯æœå‹™ç©©å®š

### æ¸¬è©¦æª¢æŸ¥
- [ ] å–®å…ƒæ¸¬è©¦é€šé
- [ ] UI æ¸¬è©¦é€šé
- [ ] æ•´åˆæ¸¬è©¦é€šé
- [ ] æ‰‹å‹•æ¸¬è©¦å®Œæˆ
```

---

## âœ… Verification Checklist (AI must confirm before suggesting code)
- [ ] All text strings use `@string/` resources
- [ ] Vibration pattern includes hour/minute separation
- [ ] Foreground service properly configured with notification
- [ ] ViewBinding used instead of findViewById
- [ ] ViewModel pattern used to separate UI logic
- [ ] Repository pattern used for data access
- [ ] Proper permission handling implemented
- [ ] Battery optimization considerations included
- [ ] App structure follows `ui/`, `service/`, `data/`, `utils/`
- [ ] ProGuard rules configured for release builds
- [ ] Android 14 compliance verified
- [ ] Accessibility features implemented
- [ ] Multi-language support verified

---

## ğŸ§  Common Pitfalls (AI must avoid)
- âŒ Accessing vibration or SharedPreferences directly in Fragments
- âŒ Skipping runtime permission checks
- âŒ Not handling Android 12+ background restrictions
- âŒ Using deprecated APIs
- âŒ Not implementing proper error handling
- âŒ Missing notification channels for Android 8+
- âŒ Not following Material Design guidelines
- âŒ Ignoring Android 14 specific requirements
- âŒ Not implementing proper accessibility support
- âŒ Missing multi-language resource files

---

## ğŸ” Security & Performance Guidelines
- Use **ProGuard/R8** for code obfuscation in release builds
- Implement proper **signing configuration** for release
- Use **encrypted SharedPreferences** for sensitive data
- Implement **battery optimization** whitelist requests
- Handle **Do Not Disturb** mode properly
- Use **WorkManager** for background tasks when possible
- Implement proper **error handling** and **crash reporting**
- Follow **Android 14 security requirements**
- Implement **Zip path traversal protection**
- Handle **exact alarm permission changes**

---

## ğŸ§¼ Maintenance Guidelines
Update this rules file when:
- Android SDK version requirements change
- New vibration APIs are introduced
- Background service restrictions are updated
- New permission requirements are added
- Material Design guidelines are updated
- ProGuard rules need modification
- Storage key logic changes
- Screen navigation or layout is restructured
- Android 14+ compliance requirements change

---

## ğŸ“± Platform-Specific Considerations
- **Android 8+**: Foreground service notifications required
- **Android 10+**: Background activity restrictions
- **Android 12+**: Foreground service special use permissions
- **Android 13+**: Notification permission required
- **Android 14+**: Exact alarm permission changes, background activity restrictions, Zip path traversal protection
- **Battery Optimization**: Request whitelist for background services
- **Do Not Disturb**: Respect user's DND settings
- **Accessibility**: Support up to 200% font scaling
- **Regional Preferences**: Support user customizations for temperature units, first day of week, number system

---

## ğŸ¯ ç¸½çµ

é€™äº›ç·¨ç¢¼è¦ç¯„ç¢ºä¿ Vibtime é …ç›®ï¼š

1. **âœ… ç¬¦åˆ Android 14 æœ€æ–°åˆè¦è¦æ±‚**
2. **âœ… æä¾›å„ªç§€çš„ç„¡éšœç¤™é«”é©—**
3. **âœ… æ”¯æŒå¤šèªè¨€å’Œæ·±è‰²æ¨¡å¼**
4. **âœ… å¯¦ç¾å®‰å…¨å¯é çš„éœ‡å‹•æœå‹™**
5. **âœ… ä¿æŒé«˜æ€§èƒ½å’Œä½è€—é›»**
6. **âœ… å…·å‚™å®Œæ•´çš„æ¸¬è©¦è¦†è“‹**
7. **âœ… ç¶­è­·æ¸…æ™°çš„ä»£ç¢¼æ–‡æª”**

éµå¾ªé€™äº›è¦ç¯„ï¼Œç¢ºä¿ Vibtime èƒ½å¤ ç‚ºè¦–éšœç”¨æˆ¶æä¾›æœ€ä½³çš„æ™‚é–“æ„ŸçŸ¥é«”é©—ï¼ğŸš€